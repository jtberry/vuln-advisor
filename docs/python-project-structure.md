# Python Project Structure — Reference Guide

This document explains how a production-quality Python project should be structured and why each piece exists. Use it as a reference when starting new projects or evaluating existing ones.

---

## The Full Layout

```
my-project/
│
├── CLAUDE.md                   # Claude Code project instructions
├── README.md                   # Public-facing documentation
├── LICENSE                     # Open source license
├── .gitignore                  # Files git should never track
├── .env.example                # Template for environment variables (safe to commit)
├── .env                        # Actual secrets — NEVER commit this
│
├── pyproject.toml              # Centralized tool configuration
├── requirements.txt            # Runtime dependencies
├── requirements-dev.txt        # Development-only dependencies
│
├── .pre-commit-config.yaml     # Automated checks that run before every commit
│
├── .github/
│   └── workflows/
│       └── ci.yml              # GitHub Actions — runs checks on every PR
│
├── main.py                     # Entry point (thin — orchestrates, does not compute)
│
├── core/                       # All application logic
│   ├── __init__.py             # Makes core/ a Python package
│   ├── models.py               # Data structures only
│   ├── fetcher.py              # External data access only
│   ├── enricher.py             # Business logic
│   └── formatter.py            # Output/presentation only
│
├── tests/                      # Automated tests (walk phase)
│   ├── __init__.py
│   ├── test_enricher.py
│   └── test_formatter.py
│
└── docs/                       # Internal documentation
    ├── architecture.md         # Design decisions and module explanations
    └── python-project-structure.md   # This file
```

---

## File-by-File Explanation

### README.md
The front door of your project. Should answer four questions immediately:
1. What does this do?
2. Who is it for?
3. How do I install and run it?
4. What does the output look like?

Everything else (contributing, roadmap, license) comes after those four.

### LICENSE
Defines the legal terms under which others can use your code. For open-source projects, MIT is the most permissive and widely understood choice. Without a license, your code is technically all rights reserved even if it is public on GitHub.

### .gitignore
Tells git which files to never track. Always include:
- `.env` — secrets must never be committed
- `venv/` or `.venv/` — virtual environments are large and machine-specific
- `__pycache__/` and `*.pyc` — Python bytecode cache files
- `.claude/` — local Claude Code settings

Rule of thumb: if a file contains secrets, is generated by a tool, or is specific to your machine, it belongs in `.gitignore`.

### .env and .env.example
`.env` stores secrets (API keys, tokens, passwords). It is in `.gitignore` and never committed.

`.env.example` is a template showing which variables are needed without their values. It is safe to commit and tells other developers what to put in their own `.env`.

```bash
# .env.example
GITHUB_TOKEN=your_token_here
DATABASE_URL=your_db_url_here
```

### pyproject.toml
The modern standard for configuring Python tools in one place. Replaces separate config files for black, isort, ruff, bandit, etc.

Before `pyproject.toml`, every tool had its own config file (`.flake8`, `.isort.cfg`, `setup.cfg`). `pyproject.toml` consolidates them all. If a tool supports it, put its config there.

### requirements.txt vs requirements-dev.txt
Split your dependencies by who needs them:

**requirements.txt** — what is needed to RUN the application
```
requests>=2.28.0
```

**requirements-dev.txt** — what is needed to DEVELOP the application (not needed in production)
```
pre-commit>=3.5.0
black>=24.0.0
ruff>=0.8.0
bandit>=1.7.0
```

This split matters when deploying. A production server only installs `requirements.txt`, keeping the deployment lean and the attack surface small.

### Virtual Environments (venv/)
A virtual environment is an isolated Python installation for your project. It prevents dependency conflicts between projects on the same machine.

```bash
python3 -m venv venv          # create it (once)
source venv/bin/activate      # activate it (every session)
pip install -r requirements.txt
deactivate                    # when done
```

Always activate your virtual environment before working on a project. Never install project dependencies into your global Python.

### .pre-commit-config.yaml
Defines automated checks that run locally before every `git commit`. If any check fails, the commit is blocked until the issue is fixed.

This is your first line of defense against bad code reaching the repo. Checks that run in this project:
- **black** — auto-formats code to a consistent style
- **isort** — sorts imports alphabetically and by type
- **ruff** — fast linter that catches bugs, style issues, and security problems
- **bandit** — static security analysis (looks for hardcoded secrets, unsafe functions)
- **pip-audit** — checks your dependencies for known CVEs

Install the hooks once after cloning:
```bash
pip install -r requirements-dev.txt
pre-commit install
```

### .github/workflows/ci.yml
Defines automated checks that run on GitHub when a pull request is opened or code is pushed to main. This is your second line of defense.

The difference from pre-commit: CI runs on GitHub's servers, not your local machine. It catches issues that might slip through locally (missing dependencies, environment differences) and gives a neutral, reviewable pass/fail record for every PR.

---

## The core/ Package

The `core/` directory holds all application logic. The `__init__.py` file (even if empty) is what makes it a Python package — without it, `from core.fetcher import fetch_nvd` would fail.

**Recommended layer structure:**

| Layer | File | Job |
|-------|------|-----|
| Models | `models.py` | Define data shapes — no logic |
| Data access | `fetcher.py` | All I/O (network, disk, database) |
| Business logic | `enricher.py` | Processing, decisions, calculations |
| Presentation | `formatter.py` | Output formatting only |

Each layer only calls downward — presentation calls logic, logic calls data access, data access calls external services. No layer skips over another or calls upward.

---

## What Good Looks Like

**Good: thin entry point**
```python
# main.py — orchestrates, delegates, does not compute
def main():
    args = parse_args()
    data = fetch(args.input)
    result = process(data)
    display(result)
```

**Bad: fat entry point**
```python
# main.py — doing too much
def main():
    args = parse_args()
    resp = requests.get(f"https://api.example.com/{args.id}")  # fetching
    score = resp.json()["score"] * 10 / args.weight            # computing
    print(f"\033[91m{score}\033[0m")                           # formatting
```

**Good: functions do one thing**
```python
def extract_cwe(cve: dict) -> str | None:
    for weakness in cve.get("weaknesses", []):
        for desc in weakness.get("description", []):
            if desc.get("value", "").startswith("CWE-"):
                return desc["value"]
    return None
```

**Bad: functions do many things**
```python
def process_cve(cve: dict) -> str:
    # extracts CWE, fetches EPSS, formats output — all in one function
    ...
```

---

## Common Mistakes to Avoid

| Mistake | Why it is a problem | Fix |
|---------|--------------------|----|
| Committing `.env` | Exposes secrets publicly | Add to `.gitignore` immediately |
| Logic in `main.py` | Hard to test, hard to reuse | Move to `core/` |
| No virtual environment | Dependency conflicts across projects | Always use `venv` |
| Installing dev tools in production | Bloated, larger attack surface | Use `requirements-dev.txt` |
| Skipping pre-commit with `--no-verify` | Bypasses all safety checks | Fix the issue instead |
| One huge file | Hard to navigate and understand | Split by responsibility |
| No type hints | Harder to catch bugs, harder to read | Add type hints to all functions |

---

## Growing the Project

As the project grows, follow this pattern:

**Adding a new data source:**
Add one function to `fetcher.py`. Do not touch anything else until the fetch works.

**Adding new analysis:**
Add logic to `enricher.py`. Fetch calls stay in `fetcher.py`. Output stays in `formatter.py`.

**Adding a new output format:**
Add a function to `formatter.py`. The enricher does not change.

**Adding a web API:**
Add a new `api.py` or `web/` package. It calls `enrich()` and returns `to_json()`. The core does not change.

This is the value of separation of concerns — new capabilities slot in without disrupting what already works.
